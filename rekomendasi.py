# -*- coding: utf-8 -*-
"""rekomendasi ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bb7F0WvL1kZis9ZadG9HcsSP1Az4Sfki

SISTEM REKOMENDASI FILM

DATASET: https://www.kaggle.com/datasets/abdallahwagih/movies

# Import library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

"""# load data"""

df = pd.read_csv('movies.csv')
df

"""load data dengan jumlah data 4803 dan 24 kolom

# Data Understanding
"""

df.info()

"""Dataset tersebut berisi 4.803 entri film dengan 24 kolom yang mencakup informasi seperti *title*, *genres*, *overview*, *cast*, *director*, *budget*, *revenue*, dan lainnya. Beberapa kolom memiliki data yang tidak lengkap, seperti `genres`, `tagline`, dan `cast`, yang perlu dipertimbangkan saat membangun model rekomendasi atau analisis data lainnya.

"""

print(f'Jumlah missing value: {df.isnull().sum()}')

"""  - Kolom homepage memiliki jumlah missing value paling banyak yaitu 3091, ini karena tidak semua film memiliki halaman resmi.
    - Beberapa kolom seperti genres, keywords, tagline, cast, dan director juga memiliki missing value yang cukup signifikan, perlu dipertimbangkan saat analisis.
    - Kolom penting seperti budget, revenue, vote_average, dan title tidak memiliki missing value, sehingga data utama terkait performa film relatif lengkap.
    - Data missing di kolom seperti runtime 2 dan release_date 1 sangat sedikit, tagline memiliki 844, cast 43, direktur 30,genres 28, dan keyword 412
"""

print(f'Jumlah baris duplikat: {df.duplicated().sum()}')

"""Hasil pemeriksaan menunjukkan bahwa tidak terdapat duplikat data pada seluruh baris dataset, yang berarti setiap rekaman film adalah unik dan tidak berulang."""

df.describe()

# Define the list of numerical columns
selected_features = ['budget', 'popularity', 'runtime','vote_average', 'vote_count']

# Matriks korelasi
corr_matrix = df[selected_features].corr()

# Visualisasi heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title("Matriks Korelasi 5 Fitur Numerik")
plt.show()

"""- Tidak ada korelasi negatif yang signifikan di sini.

- Korelasi tertinggi adalah antara popularity dan vote_count (0.78).

- Korelasi terlemah adalah antara vote_average dan budget (0.09) â†’ menunjukkan bahwa anggaran besar tidak menjamin film mendapat rating tinggi.

# Data Preparation
"""

mid = df['id'].tolist()
movie_name = df['title'].tolist()
movie_genre = df['genres'].tolist()

# Create the new DataFrame using the extracted lists
movie_new = pd.DataFrame({
    'id': mid,
    'movie_name': movie_name,
    'genre': movie_genre
})
movie_new

"""Membuat sebuah DataFrame baru bernama movie_new yang hanya berisi tiga kolom penting (id, movie_name, dan genre) dari DataFrame asli df. Tujuannya adalah untuk menyederhanakan data agar bisa digunakan lebih mudah untuk keperluan seperti sistem rekomendasi berbasis konten (Content-Based Filtering / CBF)."""

movie_new = movie_new.dropna()
print(f'Jumlah missing value setelah dihapus: {movie_new.isnull().sum()}')

"""ketika dicek sudah tidak ada missing value lagi"""

movie_new.shape

"""jumlah data dan kolom setelah dihapus adalah 4775 baris dan 3 kolom

# Content-Based Filtering (CBF)
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

tf.fit(movie_new['genre'])

tf.get_feature_names_out()

"""mengubah data genre film menjadi representasi numerik agar bisa digunakan dalam perhitungan kemiripan antar film (Content-Based Filtering)"""

tfidf_matrix = tf.fit_transform(movie_new['genre'])
tfidf_matrix.shape

"""Kode tersebut mengubah teks genre menjadi matriks TF-IDF berdimensi (jumlah film, jumlah kata unik), yang merepresentasikan seberapa penting setiap kata genre bagi masing-masing film."""

tfidf_matrix.todense()

"""mengubah matriks TF-IDF yang awalnya berbentuk sparse (jarang) menjadi bentuk dense (penuh), yaitu array 2D berisi nilai bobot TF-IDF untuk setiap genre di setiap film. Hasilnya bisa sangat besar tergantung jumlah film dan jumlah fitur unik."""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=movie_new.movie_name
).sample(22, axis=1).sample(10, axis=0)

"""untuk melihat sebagian kecil dari matriks TF-IDF dengan lebih mudah dan cepat. Ini berguna sebagai inspeksi data sebelum melanjutkan ke tahap perhitungan kesamaan (similarity)."""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""cosine_sim ini nantinya bisa digunakan untuk merekomendasikan film yang memiliki genre mirip dengan film tertentu."""

cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_new['movie_name'], columns=movie_new['movie_name'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

""" membuat DataFrame matriks kemiripan film dengan indeks dan kolom berupa judul film, baris kedua mencetak ukuran matriks, dan baris ketiga menampilkan sampel acak sebagian kolom dan baris dari matriks tersebut."""

def movie_recommendations(nama_movie, similarity_data=cosine_sim_df, items=movie_new[['movie_name', 'genre']], k=5):


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_movie].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_movie agar nama movie yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_movie, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Fungsi ini mengambil film yang paling mirip dengan nama_movie berdasarkan matriks kemiripan, menghapus film itu sendiri dari hasil, lalu mengembalikan k film teratas beserta detail judul dan genrenya."""

movie_new[movie_new.movie_name.eq('Avatar')]

"""check genre film mau yang diuji

# Evaluasi
"""

def hitung_presisi(rekomendasi_df, movie_input, items=movie_new[['movie_name', 'genre']]):
    # Ambil genre film yang menjadi input (misal 'Avatar')
    genre_input = items[items['movie_name'] == movie_input]['genre'].values[0]

    # Ambil daftar genre dari film-film hasil rekomendasi
    rekom_genres = rekomendasi_df['genre'].tolist()

    # Hitung berapa banyak film rekomendasi yang genre-nya sama persis dengan genre input
    relevan = sum([genre_input == g for g in rekom_genres])

    # Hitung total jumlah film yang direkomendasikan
    total_rekom = len(rekom_genres)

    # Hitung presisi: rasio rekomendasi relevan terhadap total rekomendasi
    presisi = relevan / total_rekom if total_rekom > 0 else 0

    # Kembalikan nilai presisi
    return presisi


# Contoh pemakaian fungsi
if 'Avatar' in cosine_sim_df.index:
    # Ambil 5 rekomendasi untuk film 'Avatar'
    rekom = movie_recommendations('Avatar', similarity_data=cosine_sim_df, items=movie_new[['movie_name', 'genre']], k=5)

    # Hitung presisi rekomendasi tersebut
    presisi = hitung_presisi(rekom, 'Avatar')

    # Tampilkan hasil rekomendasi dan nilai presisinya
    print("Rekomendasi Avatar dengan genre Action Adventure Fantasy Science Fiction:")
    print(rekom)
    print(f"Presisi: {presisi:.2f}")
else:
    # Jika film 'Avatar' tidak ada di data, tampilkan pesan ini
    print("Movie 'Avatar' tidak ditemukan di data.")

"""Hasil rekomendasi untuk film "Avatar" menunjukkan lima film yang direkomendasikan dengan genre yang sangat mirip, yakni kombinasi genre Action, Adventure, Fantasy, dan Science Fiction. Dari lima film tersebut, hanya dua film yang memiliki genre yang persis sama dengan genre film "Avatar," sehingga menghasilkan nilai presisi sebesar 0.40 atau 40%. Ini berarti 40% dari rekomendasi yang diberikan benar-benar relevan berdasarkan kesamaan genre secara tepat, sedangkan sisanya memiliki perbedaan urutan atau kombinasi genre meskipun masih serupa"""